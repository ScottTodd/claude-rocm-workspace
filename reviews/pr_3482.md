# PR Review: #3482 ‚Äî Add sccache support to build scripts with ROCm compiler wrapping

* **PR:** [#3482](https://github.com/ROCm/TheRock/pull/3482)
* **Author:** subodh-dubey-amd
* **Branch:** `users/subodh-dubey-amd/pytorch-build-sccache-support` ‚Üí `main`
* **Reviewed:** 2026-02-18
* **State:** OPEN

---

## Summary

Adds sccache integration for PyTorch wheel builds, complementing the existing ccache support. Introduces `build_tools/setup_sccache_rocm.py` which wraps ROCm LLVM compilers (clang/clang++) with sccache stubs ‚Äî necessary because hipcc invokes clang via absolute paths, bypassing CMAKE_*_COMPILER_LAUNCHER. Also modifies `build_prod_wheels.py` to add `--use-sccache` as a mutually exclusive alternative to `--use-ccache`, with try/finally cleanup for compiler restoration.

Third PR in the sccache sequence (#3369 ‚Üí #3389 ‚Üí **this** ‚Üí workflow wiring).

**Net changes:** +385 lines, -15 lines across 2 files

---

## Overall Assessment

**‚ö†Ô∏è CHANGES REQUESTED** ‚Äî The architecture is solid and the compiler wrapping approach is well-documented (mirrors PyTorch CI's own approach). The new `setup_sccache_rocm.py` is carefully written with good error handling for the binary wrapper case. However, there is a correctness bug where `setup_rocm_sccache()` is called outside the `try`/`finally` block, meaning a failure mid-wrapping leaves compilers in a broken state with no cleanup. There are also a few style and robustness issues worth addressing.

**Strengths:**

- Clean separation: generic helper in `build_tools/`, integration in `build_prod_wheels.py`
- Good provenance: references upstream PyTorch CI approach
- Careful binary-case rollback in `create_sccache_wrapper()` (temp file + move + rollback on failure)
- Mutually exclusive `--use-ccache`/`--use-sccache` args prevent conflicting usage
- Hard-fail if cache tool not found (per reviewer feedback from #3171)
- Windows handling is explicit and documented (skip wrapping, rely on CMAKE launchers)
- `finally` block guarantees compiler restore + stats on build failure

**Issues:**

- ‚ùå `setup_rocm_sccache()` is outside the `try`/`finally` ‚Äî partial wrapping failures leave compilers broken
- ‚ö†Ô∏è Symlink wrapping has no rollback on write failure (unlike the binary case)
- ‚ö†Ô∏è `sys.path.insert` inside a function body
- üí° Minor style items

---

## Detailed Review

### 1. `build_prod_wheels.py` ‚Äî sccache integration

#### ‚ùå BLOCKING: `setup_rocm_sccache()` called outside `try`/`finally` block

The PR description says "try/finally around build for guaranteed compiler restore + stats." But `setup_rocm_sccache()` is called **before** the `try` block:

```python
elif args.use_sccache:
    ...
    sccache_setup_attempted = True
    setup_rocm_sccache(rocm_dir, sccache_path)   # ‚Üê OUTSIDE try

try:                                               # ‚Üê try starts here
    if args.use_sccache and sccache_setup_attempted:
        ...
    _do_build_wheels_core(...)
finally:
    if args.use_sccache and sccache_setup_attempted:
        restore_rocm_compilers(rocm_dir)           # ‚Üê never reached if setup raises
```

`setup_rocm_sccache()` wraps two compilers (`clang`, `clang++`) sequentially. If `clang` wraps successfully but `clang++` fails, the exception propagates and the `finally` block is never entered ‚Äî leaving `clang` wrapped with no cleanup.

**Required action:** Move `setup_rocm_sccache(rocm_dir, sccache_path)` inside the `try` block, before the CMAKE launcher setup. This ensures `restore_rocm_compilers` runs in the `finally` regardless of where the failure occurs. Something like:

```python
try:
    if args.use_sccache:
        setup_rocm_sccache(rocm_dir, sccache_path)
        sccache_setup_attempted = True
        env["CMAKE_C_COMPILER_LAUNCHER"] = str(sccache_path)
        ...
    _do_build_wheels_core(...)
finally:
    if args.use_sccache and sccache_setup_attempted:
        restore_rocm_compilers(rocm_dir)
```

Note: with this structure, `sccache_setup_attempted` should be set **after** `setup_rocm_sccache()` succeeds, so the finally block only attempts restore if setup actually did something. (Though calling restore on an un-wrapped compiler is also safe ‚Äî it just prints "no path file to restore from".)

---

#### ‚ö†Ô∏è IMPORTANT: `sys.path.insert` inside function body

```python
elif args.use_sccache:
    build_tools_dir = Path(__file__).resolve().parent.parent.parent / "build_tools"
    sys.path.insert(0, str(build_tools_dir))

    from setup_sccache_rocm import (
        find_sccache,
        restore_rocm_compilers,
        setup_rocm_sccache,
    )
```

Modifying `sys.path` inside a function is a global side effect from a local scope. Per the project Python style guide: "Put all imports at the top; avoid inline imports except for circular dependencies."

**Recommendation:** Move the path setup to the top of the file (near other imports) and do a conditional or unconditional import. The `build_tools/` directory is a known location relative to the script, so this can be computed at module level:

```python
# At top of file, after other imports:
sys.path.insert(0, str(Path(__file__).resolve().parent.parent.parent / "build_tools"))
from setup_sccache_rocm import find_sccache, restore_rocm_compilers, setup_rocm_sccache
```

Or if you want to avoid the import cost when sccache isn't used, at minimum move the `sys.path.insert` to the top and keep the `from ... import` inline.

---

#### üí° SUGGESTION: `sccache_setup_attempted` flag is redundant

The flag is set to `True` right before `setup_rocm_sccache()`. If `find_sccache()` raises, we never reach the flag. If setup is moved inside the `try` block (per the blocking issue), the flag can be simplified ‚Äî `args.use_sccache` alone is sufficient, or check `sccache_path is not None`. The current dual-check `args.use_sccache and sccache_setup_attempted` reads as overly cautious. That said, it's harmless and defensive, so this is minor.

---

#### üí° SUGGESTION: Log `--start-server` failure instead of silently passing

```python
try:
    run_command([str(sccache_path), "--start-server"], ...)
except subprocess.CalledProcessError:
    pass  # Server may already be running
```

The comment is good, but `pass` swallows genuine startup failures (e.g., port conflicts, permission issues) indistinguishably from the expected "already running" case. Consider logging:

```python
except subprocess.CalledProcessError:
    print("sccache server already running (or start failed); continuing")
```

---

### 2. `build_tools/setup_sccache_rocm.py` ‚Äî compiler wrapping helper

The overall design is sound. The `create_sccache_wrapper` / `restore_compiler` pair provides a careful wrap-and-restore mechanism. The CLI interface (`--rocm-path`, `--restore`, `--sccache-path`) makes it usable standalone.

#### ‚ö†Ô∏è IMPORTANT: Symlink case has no rollback on write failure

For the **binary** case, rollback is carefully handled:
1. Write temp wrapper file
2. Move binary to backup
3. Move temp wrapper to compiler path
4. On failure: move binary back, delete temp

For the **symlink** case, there's no equivalent protection:

```python
if is_symlink:
    compiler_path.unlink()           # Symlink removed

try:
    ...
    else:  # symlink case
        compiler_path.write_text(wrapper_content)   # If THIS fails...
        compiler_path.chmod(...)
except (...) as e:
    if original_binary is not None and original_binary.exists():  # False for symlinks!
        ...
    raise RuntimeError(...)
```

If `write_text` fails after `unlink()`, the compiler symlink is gone and the except block doesn't restore it. The metadata file (`original_path_file`) does contain the symlink target, so `restore_compiler()` *could* restore it ‚Äî but only if the caller explicitly calls restore, which won't happen given the blocking issue above.

**Recommendation:** Add symlink rollback to the except block:

```python
except (...) as e:
    if is_symlink:
        try:
            symlink_target = path_info  # from the metadata file
            compiler_path.symlink_to(original_target)
        except Exception:
            pass
    elif original_binary is not None and original_binary.exists():
        ...
```

Or, mirror the binary approach: create the wrapper at a temp path first, then atomically replace the symlink.

---

#### üí° SUGGESTION: `find_sccache()` checks Linux paths on Windows

```python
common_paths = [
    Path("/usr/local/bin/sccache"),      # Linux-only
    Path("/opt/cache/bin/sccache"),       # Linux-only
    Path.home() / ".cargo" / "bin" / "sccache",  # Linux-only (.exe needed on Windows)
]
if is_windows:
    common_paths.extend([...])
```

The Linux paths are always checked even on Windows where they can never exist. This is harmless (they just won't exist), but could be cleaner with `if not is_windows:` / `else:` branches.

---

#### üí° SUGGESTION: Module docstring could note the two-repo relationship

`setup_sccache_rocm.py` lives in `build_tools/` (TheRock generic) but is imported from `external-builds/pytorch/build_prod_wheels.py` via `sys.path` manipulation. A brief note in the docstring about intended consumers would help future readers understand the cross-directory import.

---

### 3. Argument parsing changes

The `--use-ccache` argument changed from `BooleanOptionalAction` to `store_true`, which means `--no-use-ccache` is no longer accepted. I verified that no workflow or script in the repo passes `--no-use-ccache` or `--use-ccache`, so this is safe in practice. Since neither flag is used yet (the next PR wires it into workflows), this is a non-issue.

The mutually exclusive group is the right approach for `--use-ccache` / `--use-sccache`.

---

## Recommendations

### ‚ùå REQUIRED Before Human Review (Blocking):

1. **Move `setup_rocm_sccache()` inside the `try` block** so that the `finally` cleanup runs even if compiler wrapping partially fails.

### ‚úÖ Recommended Before Human Review:

1. **Add symlink rollback** in `create_sccache_wrapper`'s except block, or use the same temp-file-then-atomic-replace approach used for binaries.
2. **Move `sys.path.insert`** to module level or top of file rather than inside the function body.

### üí° Consider:

1. Log the `--start-server` failure rather than silently passing.
2. Guard Linux-only paths in `find_sccache()` behind `if not is_windows`.
3. Add a docstring note about the cross-directory import relationship.

### üìã Future Follow-up:

1. Tests for `setup_sccache_rocm.py` ‚Äî the wrap/restore logic is complex enough to warrant unit tests (especially the symlink vs binary cases and rollback behavior).
2. The next PR in the sequence (workflow wiring) should verify end-to-end that `--use-sccache` works with both fresh and cached builds.
3. **Consider adding `HIP_CLANG_LAUNCHER` to hipcc itself** ‚Äî see [Architectural Notes](#architectural-notes-compiler-wrapping-vs-hipcc-launcher) below.

---

## Testing Recommendations

Since this PR has no workflow changes (sccache is wired but not yet invoked by CI):

- Manually test the wrap/restore cycle: run `python setup_sccache_rocm.py --rocm-path <path>` and verify wrappers are created, then `--restore` and verify originals are restored.
- Test the symlink case (typical in ROCm installations where `clang` ‚Üí `clang-18` etc.) and the binary case.
- Test the failure path: what happens if `--rocm-path` points to a non-existent directory, or if the LLVM bin dir doesn't contain clang?
- Verify `build_prod_wheels.py --use-sccache` fails cleanly when sccache is not installed.
- Verify `--use-ccache --use-sccache` is rejected by argparse.

---

## Architectural Notes: Compiler Wrapping vs hipcc Launcher

The compiler wrapping approach in this PR exists because hipcc invokes clang via absolute paths, bypassing `CMAKE_*_COMPILER_LAUNCHER`. This is a known limitation of hipcc's architecture.

### Why wrapping is necessary today

In `compiler/amd-llvm/amd/hipcc/src/hipBin_amd.h`, `getHipCC()` (line 364) resolves clang to an absolute path (e.g., `/path/to/llvm/bin/clang++`), and `executeHipCCCmd()` (line 870) constructs a command string and execs it directly. There is no launcher indirection ‚Äî even if CMake prepends sccache to the hipcc invocation, hipcc internally calls clang at its resolved path, bypassing sccache entirely.

### `HIP_CLANG_LAUNCHER` ‚Äî doesn't exist yet

There was an upstream PR ([ROCm/llvm-project#14](https://github.com/ROCm/llvm-project/pull/14)) to add a `HIP_CLANG_LAUNCHER` environment variable to hipcc. It was **closed without merging** (June 2024). The feature does not exist in the current hipcc source, either upstream or in TheRock's copy at `compiler/amd-llvm/amd/hipcc/`.

### Potential improvement: land `HIP_CLANG_LAUNCHER` in TheRock's hipcc

TheRock controls the hipcc source at `compiler/amd-llvm/amd/hipcc/`. A small patch to `executeHipCCCmd()` around line 870 could add launcher support:

```cpp
// Current code:
compiler = getHipCC();
string CMD = compiler;

// With launcher support:
compiler = getHipCC();
string launcher;
if (const char* env = std::getenv("HIP_CLANG_LAUNCHER")) {
    launcher = env;
}
string CMD = launcher.empty() ? compiler : launcher + " " + compiler;
```

This would eliminate the need for the compiler wrapping approach entirely ‚Äî `CMAKE_HIP_COMPILER_LAUNCHER` could set `HIP_CLANG_LAUNCHER` in the environment, and sccache/ccache would work transparently with hipcc. Benefits:

- No destructive modification of the ROCm install tree
- Works on Windows (where shell script wrappers can't intercept `.exe` calls)
- Reusable by all hipcc consumers, not just TheRock/PyTorch builds
- `setup_sccache_rocm.py` becomes unnecessary (or reduced to just setting env vars + CMAKE launchers)

This is out of scope for this PR, but worth tracking as future work. The compiler wrapping approach is the right pragmatic solution for now.

---

## Conclusion

**Approval Status: ‚ö†Ô∏è CHANGES REQUESTED**

The architecture and approach are well-motivated. The compiler wrapping design is solid and well-documented. The main blocking issue is a straightforward fix ‚Äî move `setup_rocm_sccache()` inside the `try` block so the stated "guaranteed compiler restore" guarantee actually holds. The symlink rollback gap is worth fixing too since it compounds with the try/finally issue. Once those are addressed, this is in good shape.

The longer-term path to eliminating the wrapping hack would be adding `HIP_CLANG_LAUNCHER` support directly to hipcc (see [Architectural Notes](#architectural-notes-compiler-wrapping-vs-hipcc-launcher)).
