# PR Review: #3475 â€” Fix split artifact flatten: move to post-split step

* **PR:** [#3475](https://github.com/ROCm/TheRock/pull/3475)
* **Author:** stellaraccident (Stella Laurenzo)
* **Branch:** `users/stellaraccident/fix-split-artifact-flatten` â†’ `main`
* **Reviewed:** 2026-02-18
* **State:** OPEN

---

## Summary

Fixes two issues with `THEROCK_KPACK_SPLIT_ARTIFACTS=ON`:

- **#3448**: `dist/rocm/` contained unsplit (fat binary) artifacts instead of kpack-transformed split artifacts, because the flatten step ran as part of the populate command before splitting.
- **#3447**: The pre-split flatten created additional hardlink aliases (4-way aliasing) to the same inodes that `stage/` and `dist/` point to, increasing contention during concurrent split + downstream build phases (intermittent SIGBUS/truncation).

The fix restructures the pipeline so that for split artifacts, flatten runs **after** all split steps complete, reading from split outputs (new inodes via `shutil.copy2`) instead of from the multiply-aliased unsplit hardlinks.

**Net changes:** +198 lines, -2 lines across 3 files

---

## Overall Assessment

**âœ… APPROVED** â€” This is a clean, well-motivated fix. The pipeline reordering is correct, the new `artifact-flatten-split` command handles the runtime discovery of split output dirs appropriately, the CMake dependency chain is properly wired, and the tests cover the key scenarios. The `VERBATIM` additions are a good housekeeping bonus.

**Strengths:**

- Clear problem diagnosis with links to investigation notes
- Correct dependency chain: split manifests â†’ flatten stamp â†’ downstream targets
- Runtime discovery via glob handles the xnack suffix problem (can't predict dir names at configure time)
- Good test coverage: happy path with multiple prefixes/variants, stray dirs without manifests, and no-match warning case
- Non-split builds are completely unaffected (guard: `AND NOT _should_split`)
- Expunge targets updated to clean up the new flatten stamp
- `VERBATIM` added to all `add_custom_command`/`add_custom_target` calls in the function

**Issues:**

- ðŸ’¡ Minor suggestions only

---

## Detailed Review

### 1. `cmake/therock_artifacts.cmake` â€” pipeline restructuring

The core fix is correct. The existing flatten:

```cmake
# Before (line 191): always flatten during populate
if(ARG_DISTRIBUTION)
```

becomes:

```cmake
# After: only flatten non-split artifacts during populate
if(ARG_DISTRIBUTION AND NOT _should_split)
```

For split artifacts, a new post-split flatten step is added that:
1. Depends on `${_split_manifest_files}` (all per-component split manifests)
2. Runs `artifact-flatten-split` which discovers split output dirs by globbing
3. Produces a `.flatten-${slice_name}.stamp` file
4. The stamp is appended to `_manifest_files`, wiring it into the downstream dependency chain

The dependency chain is:
```
stage.stamp â†’ unsplit manifests â†’ split manifests â†’ flatten stamp â†’ downstream targets
```

This is correct.

#### ðŸ’¡ SUGGESTION: `VERBATIM` additions are good but one pre-existing call was missed

The PR adds `VERBATIM` to 6 `add_custom_command`/`add_custom_target` calls. This is good practice (prevents shell interpretation issues). I notice the `install(CODE ...)` block at line ~124 has a `add_custom_command` that also got `VERBATIM` added. One pre-existing call that was NOT touched is the `add_custom_target("dist-${ARG_DISTRIBUTION}")` at line 99 â€” but that one has no `COMMAND`, so `VERBATIM` doesn't apply. The coverage looks complete.

---

### 2. `build_tools/fileset_tool.py` â€” `artifact-flatten-split` command

The new `_do_artifact_flatten_split()` function is clean and follows the pattern of the existing `_do_artifact_flatten()`. Key design decisions:

- **Glob-based discovery**: `artifacts_dir.glob(f"{prefix}_*")` finds split output dirs. The `sorted()` ensures deterministic ordering. Candidates are validated by checking for `artifact_manifest.txt`.
- **Warning on no match**: Prints a warning but doesn't fail. This is appropriate â€” a missing split output could indicate a configuration issue, but shouldn't break the build if the artifact was legitimately not produced.
- **Reuses `ArtifactPopulator`**: The flatten logic delegates to the same `ArtifactPopulator` class used by `artifact-flatten`, ensuring consistent behavior.

#### ðŸ’¡ SUGGESTION: Consider whether warning should go to stderr

```python
print(
    f"Warning: no split artifact dirs found in {artifacts_dir} "
    f"for prefixes: {args.prefixes}"
)
```

Warnings conventionally go to stderr. The existing `_do_artifact_flatten` doesn't have a similar warning path, but for a build tool, `print(..., file=sys.stderr)` would be more conventional. This is minor since the output is captured by CMake's custom command anyway.

---

### 3. `build_tools/tests/fileset_tool_test.py` â€” tests

Two tests added:

**`testArtifactFlattenSplit`**: Exercises the happy path with:
- Two variants of one prefix (`miopen_lib_generic`, `miopen_lib_gfx1201`)
- One variant of a second prefix (`miopen_dev_generic`)
- A stray directory without `artifact_manifest.txt` (should be excluded)
- Verifies verbose output lists discovered dirs
- Verifies flattened files from all three artifact dirs are present

**`testArtifactFlattenSplitNoMatch`**: Verifies the no-match warning path doesn't fail.

Both tests follow the existing patterns in the file (using `write_text`, `capture` helpers) and test via subprocess invocation of `fileset_tool.py`, which matches how the tool is actually invoked from CMake.

#### ðŸ’¡ SUGGESTION: Could test hardlink behavior

The existing `testHardlinkPreservation` test verifies that `artifact-flatten` preserves hardlinks. The new `testArtifactFlattenSplit` doesn't verify this. Since the whole motivation is breaking the hardlink aliasing chain, a test that verifies split-flatten produces files with different inodes from the "unsplit" source would directly validate the fix for #3447. That said, this may be hard to test in isolation since the split step itself (which creates new inodes via `shutil.copy2`) isn't part of this test â€” the test simulates pre-split output.

---

### 4. CMake dependency chain analysis

Tracing the full chain for split artifacts after this PR:

```
_stamp_file_deps (stage stamps)
  â†’ _manifest_files (unsplit manifests, from populate command)
    â†’ _split_manifest_files (split manifests, from split command)
      â†’ _flatten_stamp (.flatten-${slice_name}.stamp, from flatten-split command)
        â†’ ${_target_name}_files (custom target depending on all manifests + flatten stamp)
          â†’ ${_target_name} (the artifact target)
```

The flatten stamp is correctly appended to `_manifest_files` (line ~299 in the diff):
```cmake
if(ARG_DISTRIBUTION)
  list(APPEND _manifest_files "${_flatten_stamp}")
endif()
```

This means the flatten must complete before the target is considered built. Downstream targets depending on the artifact will see the flattened `dist/` populated.

Expunge is also updated to clean the stamp file (line ~393 in the diff), preventing stale stamps from confusing ninja on rebuild.

---

## Recommendations

### ðŸ’¡ Consider:

1. Warning to stderr instead of stdout in `_do_artifact_flatten_split`.
2. A test that directly validates the inode-separation property (if feasible without the full split pipeline).

### ðŸ“‹ Future Follow-up:

1. The `_split_component_dirs` only tracks the `_generic` dir (line 224 in the existing code, per the comment about only the generic manifest being tracked). If someone deletes an arch-specific split artifact, ninja won't notice. This pre-existing limitation is documented in the code comments and is unchanged by this PR.

---

## Testing Recommendations

- Run the new tests: `python -m pytest build_tools/tests/fileset_tool_test.py -v -k "FlattenSplit"`
- Build with `THEROCK_KPACK_SPLIT_ARTIFACTS=ON` and verify:
  - `dist/rocm/` contains split (not fat) artifacts
  - `dist/rocm/` files have different inodes from `artifacts-unsplit/` files
  - `.kpack/` files and `.kpm` manifests are present in `dist/rocm/`
- Build WITHOUT split and verify unchanged behavior

---

## Conclusion

**Approval Status: âœ… APPROVED**

Well-structured fix with clear diagnosis, correct dependency chain, appropriate tests, and no impact on non-split builds. The `VERBATIM` additions are a nice bonus. Only minor suggestions, nothing blocking.
