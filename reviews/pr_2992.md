# PR Review: #2992 - Add unit tests covering core packaging script functionality

* **PR:** [#2992](https://github.com/ROCm/TheRock/pull/2992)
* **Author:** raramakr
* **Branch:** `users/raramakr/unittest-pkg` -> `main`
* **Reviewed:** 2026-01-21
* **Status:** OPEN

---

## Summary

This PR adds comprehensive unit tests for the ROCm Linux packaging scripts (`packaging_utils.py` and `build_package.py`). The tests cover input validation, metadata extraction, package creation logic for both DEB and RPM formats, and error handling scenarios.

**Net changes:** +2248 lines across 3 files:
- `build_tools/packaging/tests/LINUX_PACKAGING_TEST_README.md` (+211 lines)
- `build_tools/packaging/tests/test_linux_build_package.py` (+1174 lines)
- `build_tools/packaging/tests/test_linux_packaging_utils.py` (+863 lines)

---

## Overall Assessment

**‚úÖ APPROVED** - This is a solid test suite that adds significant value to the packaging infrastructure.

**Strengths:**
- Comprehensive coverage of both `packaging_utils.py` and `build_package.py`
- Good use of mocking to isolate tests from external dependencies (dpkg-buildpackage, rpmbuild)
- Tests cover both success and failure paths
- Proper temporary directory management with `setUp`/`tearDown`
- Well-organized test classes grouped by function under test
- Good edge case coverage (empty inputs, disabled packages, meta packages vs regular packages)
- Includes helpful README with clear instructions for running tests

**Minor Issues:**
- Some style guide deviations (no type hints, some broad exception handling)
- A few tests could be more thorough in their assertions

---

## Detailed Review

### 1. Test Structure and Organization

The tests are well-organized with clear class names mapping to functions under test. This is a good pattern that makes it easy to find tests for specific functionality.

### 2. `test_linux_packaging_utils.py`

#### üí° SUGGESTION: Add type hints to test helper functions

The test files don't include type hints. While this is common in test code, the project style guide recommends type hints "liberally." For test code this is optional but would improve IDE support.

**Location:** Lines 1424-1461, class `TestPrintFunctionName`

```python
# Current
def test_print_function_name(self, mock_print):
    ...

# Suggested
def test_print_function_name(self, mock_print: MagicMock) -> None:
    ...
```

#### üí° SUGGESTION: Consider using `pytest` instead of `unittest`

The style guide mentions using `pytest` for testing. While `unittest` is fine and works, `pytest` provides more concise test patterns and better assertion introspection. This is a future consideration, not blocking.

**Note:** The README explicitly states "No additional packages like pytest are required" which is a valid design choice for minimal dependencies.

### 3. `test_linux_build_package.py`

#### ‚ö†Ô∏è IMPORTANT: Some tests mock too much, reducing actual validation

Several tests mock so many dependencies that they become more about verifying mock calls than actual functionality.

**Location:** Lines 960-1023, `TestCreateVersionedDebPackage.test_create_versioned_deb_with_artifacts`

This test patches 14 different functions. While this isolates the test, it means the test verifies that functions are called in sequence rather than that they produce correct output. Consider adding a few integration-style tests with fewer mocks.

**Recommendation:** Add integration tests that use real temporary files and verify actual file content for critical paths.

#### üí° SUGGESTION: Verify file contents in more tests

Some tests only check file existence without verifying contents.

**Location:** Lines 262-273, `test_copy_regular_files`

```python
# Current - good!
self.assertTrue((self.dest_dir / "test.txt").exists())
self.assertEqual((self.dest_dir / "test.txt").read_text(), "test content")
```

This test does verify content, which is good. Other tests like `test_generate_rules_file` (lines 405-431) only check existence and permissions without verifying the actual rules content.

#### üí° SUGGESTION: Test error messages, not just exceptions

Some tests verify that exceptions are raised but don't check the error message.

**Location:** Lines 868-883, `test_run_invalid_version`

```python
# Current
with self.assertRaises(ValueError):
    build_package.run(args)

# Better - verify the error message helps debugging
with self.assertRaises(ValueError) as cm:
    build_package.run(args)
self.assertIn("version", str(cm.exception).lower())
```

### 4. `LINUX_PACKAGING_TEST_README.md`

#### üí° SUGGESTION: Add CI integration instructions

The README explains how to run tests locally but doesn't mention how tests integrate with CI. Consider adding a section about running tests in CI workflows.

### 5. Code Style

#### üí° SUGGESTION: Use modern type hints syntax

Per the style guide, use `list[str]` not `List[str]`, and `T | None` not `Optional[T]`.

The test files import from `unittest.mock` which is correct, but the mocked parameters could benefit from type hints.

#### üí° SUGGESTION: Consider extracting common test fixtures

Several test classes have identical `setUp`/`tearDown` methods for creating and cleaning temporary directories.

**Location:** Multiple classes (TestCopyPackageContents, TestGenerateChangelogFile, TestGenerateInstallFile, etc.)

```python
# Could be extracted to a base class or fixture
def setUp(self):
    self.temp_dir = tempfile.mkdtemp()
    ...

def tearDown(self):
    if os.path.exists(self.temp_dir):
        shutil.rmtree(self.temp_dir)
```

While not blocking, this duplication could be reduced with a base test class.

### 6. Test Coverage Claims

The README claims 96% overall coverage (99% for `packaging_utils.py`, 94% for `build_package.py`). These are good numbers, but the coverage measurement methodology isn't documented.

#### üí° SUGGESTION: Add coverage measurement instructions

Document how to generate and verify coverage reports.

---

## Recommendations

### ‚úÖ Recommended Before Human Review:

1. **Consider adding a few integration tests** that exercise multiple functions together with real files rather than all mocks
2. **Verify error messages in exception tests** where the message is important for debugging

### üí° Consider:

1. Add type hints to test functions (optional for test code)
2. Extract common test fixtures to a base class
3. Add coverage measurement instructions to README
4. Add CI integration documentation

### üìã Future Follow-up:

1. Consider migrating to `pytest` for more concise test patterns (separate effort)
2. Add property-based testing for version parsing functions
3. Add mutation testing to verify test effectiveness

---

## Testing Recommendations

To verify these tests:

```bash
cd TheRock/build_tools/packaging/tests

# Run all tests
python3 -m unittest discover -v

# Run specific test files
python3 -m unittest test_linux_packaging_utils -v
python3 -m unittest test_linux_build_package -v

# Run with coverage (if coverage.py is available)
python3 -m coverage run -m unittest discover -v
python3 -m coverage report
```

---

## Conclusion

**Approval Status: ‚úÖ APPROVED**

This PR adds valuable test coverage to the packaging infrastructure. The tests are well-organized, cover important functionality, and use appropriate mocking strategies. While there are opportunities for improvement (integration tests, type hints, error message verification), these are not blocking issues.

The test suite will help prevent regressions in the packaging scripts and provides good documentation of expected behavior through the test cases themselves. This is exactly the kind of defensive testing that strengthens confidence in the build pipeline.

**Recommended next step:** Merge after addressing any comments from other reviewers.
