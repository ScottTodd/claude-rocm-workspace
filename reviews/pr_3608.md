# PR Review: #3608 ‚Äî Fix multi-arch Python packaging: per-family library dedup and per-family devel wheels

* **PR:** [#3608](https://github.com/ROCm/TheRock/pull/3608)
* **Author:** marbre
* **Branch:** `users/marbre/python-packaging` ‚Üí `main`
* **Reviewed:** 2026-02-25
* **Files changed:** 3 (+489, -36)

---

## Summary

This PR fixes two critical bugs in multi-architecture Python wheel builds (e.g. `gfx120X-all` + `gfx94X-dcgpu`):

1. **Empty library wheels**: A shared global `PopulatedFiles` tracker on `Parameters` caused whichever architecture iterated first to claim all shared relpaths (e.g. `lib/librocblas.so`), leaving other architectures with empty packages. Python set iteration order made this non-deterministic.

2. **Single devel wheel**: Only one `rocm-sdk-devel` package was generated using `params.default_target_family`, preventing other GPU families from getting usable devel packages.

The fix moves `PopulatedFiles` from `Parameters` (shared) to `PopulatedDistPackage` (per-instance), adds cross-package search helpers with target-family filtering, and produces per-family devel wheels.

**Net changes:** +489 lines, -36 lines across 3 files

---

## Overall Assessment

**‚úÖ APPROVED** ‚Äî Well-motivated bug fix with sound architecture and good test coverage.

**Strengths:**

- Root cause analysis is clear and the fix directly addresses it
- Architecture change is clean: per-instance tracking with cross-package search
- New test file covers both the unit-level bug fix and integration-level multi-arch behavior
- Build ordering is restructured to avoid accidental inclusion of devel dirs
- Removed pre-existing dead code (`build_args` double-assignment in `build_packages`)

**Issues:**

- One stale comment (IMPORTANT)
- A few minor suggestions

---

## Detailed Review

### 1. py_packaging.py ‚Äî Core Fix: Per-Instance `PopulatedFiles`

#### ‚úÖ Correct: `PopulatedFiles` moved to `PopulatedDistPackage`

The central change is moving `self.files = PopulatedFiles()` from `Parameters.__init__` to `PopulatedDistPackage.__init__`. This ensures each package tracks its own materialized files independently, eliminating the cross-architecture interference bug.

All references updated consistently:
- `self.params.files` ‚Üí `self.files` in `populate_runtime_files`, `_populate_runtime_symlink`, `_populate_file`
- `self.params.files.soname_aliases` ‚Üí `self.files.soname_aliases`
- `self.params.files.mark_populated` ‚Üí `self.files.mark_populated`

#### ‚úÖ Correct: Package self-registration

`self.params.populated_packages.append(self)` at the end of `populate_runtime_files()` ensures only fully-populated packages are searchable. Packages that don't call `populate_runtime_files()` (like `meta`) are correctly excluded from cross-package searches.

#### ‚úÖ Correct: `_find_populated()` and `_find_soname_alias()`

The target-family filtering logic is sound:
- Skips packages from a *different* non-None target family
- Includes packages with matching target family
- Includes generic packages (`target_family=None`) for arch-neutral content (e.g. core)
- Returns first match, which is correct since within a family there should be at most one package owning a given relpath

#### ‚ö†Ô∏è IMPORTANT: Stale comment in `_devel_artifact_filter`

The filter now uses `self.target_family` instead of `self.params.default_target_family`, but the comment still says "We only materialize the default target family for devel packages." This is misleading since each devel package now filters to *its own* target family.

**Recommendation:** Update the comment to reflect the new behavior, e.g.:
```python
if (
    an.target_family != "generic"
    and an.target_family != self.target_family
):
    # Only include artifacts for this devel package's target family.
    return False
```

#### ‚úÖ Correct: `_populate_devel_file` updates

The switch from `self.params.files.soname_aliases.get(relpath)` to `self._find_soname_alias(relpath)` and from `self.params.files.has(relpath)` to `self._find_populated(relpath)` is clean. The destructured `populated_package, populated_path = populated` maintains the same interface used for symlink construction.

### 2. py_packaging.py ‚Äî `build_packages()` Refactoring

#### ‚úÖ Correct: New optional parameters

Adding `package_dirs` and `dist_dir` parameters with sensible defaults (scan `dest_dir` / use `dest_dir/dist`) maintains backward compatibility while enabling per-family builds.

#### ‚úÖ Good: Dead code removal

The old double-assignment of `build_args` (first with `python -m build`, then immediately overwritten with `setup.py`) is cleaned up. Only the `setup.py` invocation remains.

#### üí° SUGGESTION: `effective_dist_dir` naming

The `effective_dist_dir` variable name is fine but slightly verbose. Consider just `dist_dir` with early reassignment:
```python
if dist_dir is None:
    dist_dir = dest_dir / "dist"
dist_dir.mkdir(parents=True, exist_ok=True)
```
This is minor and entirely optional.

### 3. build_python_packages.py ‚Äî Build Orchestration

#### ‚úÖ Correct: Sorted iteration

`sorted(params.all_target_families)` ensures deterministic iteration order. Previously `params.all_target_families` came from a set, so iteration order was non-deterministic ‚Äî the same root cause as the dedup bug.

#### ‚úÖ Good: Build ordering change

Building non-devel wheels first (before devel package directories exist) prevents the default `dest_dir.iterdir()` scan from accidentally picking up devel packages. The comment explaining this is clear and helpful.

#### ‚úÖ Correct: Per-family devel packages

Each target family now gets its own devel package built to `dist/{target_family}/`. This ensures all families get usable devel wheels. The explicit `package_dirs=[devel.path]` ensures only the current family's devel package is built in each iteration.

#### üí° SUGGESTION: Consider guarding against ordering regressions

The correctness of the non-devel build depends on devel package directories not existing yet. If someone later moves code around, this invariant could break silently. One lightweight option would be to pass `package_dirs` explicitly for the non-devel build too, rather than relying on filesystem scanning:
```python
non_devel_dirs = [p for p in [meta.path, core.path] + [lib.path for lib in lib_packages]]
build_packages(args.dest_dir, package_dirs=non_devel_dirs, ...)
```
This is more of a future-proofing thought than a required change.

### 4. py_packaging_test.py ‚Äî Test Suite

#### ‚úÖ Good: `PopulatedFilesTest`

Tests per-instance isolation directly, including:
- `test_two_instances_are_independent` ‚Äî the regression test for the bug
- `test_soname_aliases_are_per_instance`
- `test_mark_populated_raises_on_duplicate`

#### ‚úÖ Good: `MultiArchPackagingTest`

Integration tests use real artifact directories with `.txt` file stand-ins. Tests cover:
- Shared relpaths across architectures
- Package self-registration
- Cross-package search with `_find_populated` and `_find_soname_alias`
- Target-family filtering (matching family, different family, generic fallback)

#### üí° SUGGESTION: Test file naming convention

The test file is named `py_packaging_test.py`. Verify this matches the project convention ‚Äî I see some projects use `test_*.py` (pytest default) vs `*_test.py`. The existing file at `build_tools/tests/` may have a precedent to follow. Either way, minor.

#### üí° SUGGESTION: Consider a negative test for `_find_populated` with wrong family

There's `test_find_populated_prefers_matching_target_family` which tests that the *correct* family is returned. Consider also testing that when *only* a wrong-family package has a relpath, `_find_populated` returns `None` (rather than the wrong-family package). This would strengthen the guarantee that devel packages don't accidentally link to the wrong architecture's libraries.

---

## Recommendations

### ‚ùå REQUIRED (Blocking):

None.

### ‚úÖ Recommended:

1. Update the stale comment in `_devel_artifact_filter` to reflect that each devel package filters to its own `self.target_family`, not the global default.

### üí° Consider:

1. Simplify `effective_dist_dir` naming in `build_packages()`.
2. Pass explicit `package_dirs` for non-devel builds to guard against future ordering regressions.
3. Add a negative test for `_find_populated` where only a wrong-family package has the relpath.
4. Verify test file naming convention (`*_test.py` vs `test_*.py`).

### üìã Future Follow-up:

1. The PR author notes that additional refactoring to the `rocm` sdist will be needed ‚Äî track as follow-up work.
2. The test suite uses `.txt` files as stand-ins for shared libraries, meaning soname/patchelf code paths aren't exercised end-to-end. Consider adding Linux-specific integration tests with real ELF binaries in the future.

---

## Testing Recommendations

- Run the new test suite: `python -m pytest build_tools/tests/py_packaging_test.py -v`
- End-to-end validation: Build multi-arch packages with at least two target families and verify both library wheels contain the expected runtime libraries.
- Verify per-family devel wheels: Check that `dist/{target_family}/` directories each contain a devel wheel.

---

## Conclusion

**Approval Status: ‚úÖ APPROVED**

This is a well-executed fix for a real multi-arch packaging bug. The architecture change (per-instance `PopulatedFiles` with cross-package search helpers) is sound and directly addresses the root cause. The test suite provides good coverage of both the unit-level fix and the integration-level multi-arch behavior. The one recommended change (stale comment) is non-blocking. The PR is ready for human review.
