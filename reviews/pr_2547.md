# Code Review: Generate a manifest file for Pytorch builds

* **PR:** #2547
* **Branch:** (not specified in PR)
* **Author:** erman-gurses
* **Reviewers:** ScottTodd, amd-aakash, marbre
* **Reviewed:** 2026-01-06
* **Status:** OPEN
* **Closes:** #2481

## Summary

This PR adds the ability to generate a JSON manifest file for PyTorch wheel builds, capturing metadata about the build artifacts, source repositories, and build environment. The manifest is uploaded to S3 alongside the built wheels for traceability and downstream tooling.

**Changes:**
- Add manifest upload step to Linux and Windows PyTorch wheel build workflows
- Integrate manifest generation into `build_prod_wheels.py` (new `--write-manifest` flag, default True)
- Add new script `generate_pytorch_manifest.py` to create the manifest JSON

**Lines changed:** +292 / -0

**Example manifest output:** Includes wheel metadata (name, size, labels), git commit info for all PyTorch components, ROCm version, GitHub Actions metadata, and more.

---

## Review Results

### ‚ùå BLOCKING Issues

#### 1. Silent Exception Handling Violates Fail-Fast Principle (generate_pytorch_manifest.py:54-59)

**File:** `external-builds/pytorch/generate_pytorch_manifest.py`
**Location:** Lines 54-59

**Issue:**
The `capture()` function silently catches all exceptions and returns an empty string:

```python
def capture(cmd: List[str], cwd: Optional[Path] = None) -> str:
    try:
        return subprocess.check_output(
            cmd, cwd=str(cwd) if cwd else None, stderr=subprocess.STDOUT, text=True
        ).strip()
    except Exception:  # ‚ùå BLOCKING: Bare except
        return ""
```

This violates the fail-fast principle from CLAUDE.md Python coding standards. If git commands fail (e.g., git not installed, directory not a repo, permission issues), the function silently returns empty string and the manifest contains incomplete/missing data.

**Impact:**
- Git command failures are hidden, manifest has empty/missing fields
- Debugging build issues becomes harder when source info is silently missing
- Users can't tell if manifest is incomplete due to error vs. intentional omission

**Fix Required:**
```python
def capture(cmd: List[str], cwd: Optional[Path] = None) -> str:
    """
    Execute a command and return its stdout.

    Raises:
        subprocess.CalledProcessError: If command fails
        FileNotFoundError: If command not found
    """
    return subprocess.check_output(
        cmd, cwd=str(cwd) if cwd else None, stderr=subprocess.STDOUT, text=True
    ).strip()
```

Then handle the exception at call sites where appropriate, or let it propagate to fail the build.

---

#### 2. Silent Failures in Wheel Parsing (generate_pytorch_manifest.py:17-49)

**File:** `external-builds/pytorch/generate_pytorch_manifest.py`
**Location:** Lines 17-49

**Issue:**
The `parse_wheel_name()` function silently returns empty dict on parsing failures:

```python
def parse_wheel_name(filename: str) -> Dict[str, str]:
    # Best-effort wheel parse per PEP 427:
    if not filename.endswith(".whl"):
        return {}  # ‚ùå Silent failure

    parts = filename[:-4].split("-")
    if len(parts) < 5:
        return {}  # ‚ùå Silent failure

    # ... parsing logic ...
```

If a wheel filename is malformed, it gets added to the manifest with empty labels, which breaks downstream tooling that expects these fields.

**Impact:**
- Malformed wheels are silently added to manifest with missing metadata
- Downstream tools (package indexers, deployment scripts) may fail or misbehave
- No visibility into whether wheels are correctly named

**Fix Required:**
```python
def parse_wheel_name(filename: str) -> Dict[str, str]:
    """
    Parse wheel filename per PEP 427.

    Args:
        filename: Wheel filename (e.g., 'torch-2.9.1-cp313-cp313-linux_x86_64.whl')

    Returns:
        Dictionary with keys: distribution, version, python_tag, abi_tag, platform_tag,
        and optionally build_tag

    Raises:
        ValueError: If filename is not a valid wheel name
    """
    if not filename.endswith(".whl"):
        raise ValueError(f"Not a wheel file: {filename}")

    parts = filename[:-4].split("-")
    if len(parts) < 5:
        raise ValueError(
            f"Invalid wheel filename '{filename}': expected at least 5 parts "
            f"(distribution-version-python-abi-platform.whl), got {len(parts)}"
        )

    # ... rest of parsing ...
    return meta
```

---

#### 3. No Validation That Wheels Exist Before Manifest Generation (build_prod_wheels.py:513-535)

**File:** `external-builds/pytorch/build_prod_wheels.py`
**Location:** Lines 513-535 (in the diff)

**Issue:**
The manifest generation step runs after build completion but doesn't verify that any wheels were actually produced:

```python
print("--- Builds all completed")

# Write manifest for built wheels (into <output-dir>/manifests).
if args.write_manifest:
    manifest_script = script_dir / "generate_pytorch_manifest.py"
    cmd = [sys.executable, manifest_script, ...]
    exec(cmd, cwd=script_dir)
```

If builds fail silently or produce no wheels, the manifest generation will:
- Create a manifest with an empty `artifacts` list
- Upload an effectively useless manifest to S3
- Not alert the user to the problem

**Fix Required:**
Add validation before manifest generation:

```python
print("--- Builds all completed")

# Write manifest for built wheels (into <output-dir>/manifests).
if args.write_manifest:
    # Verify that wheels were produced
    wheel_files = list(args.output_dir.rglob("*.whl"))
    if not wheel_files:
        raise RuntimeError(
            f"No wheel files found in {args.output_dir}. "
            "Build may have failed. Not generating manifest."
        )

    print(f"--- Generating manifest for {len(wheel_files)} wheel(s)")
    manifest_script = script_dir / "generate_pytorch_manifest.py"
    # ... rest of command ...
```

---

### ‚ö†Ô∏è IMPORTANT Issues

#### 4. Silent Git Failures May Produce Incomplete Manifests (generate_pytorch_manifest.py:62-72)

**File:** `generate_pytorch_manifest.py`
**Location:** Lines 62-72

**Issue:**
The `git_head()` function returns `None` if any git operation fails, but doesn't distinguish between expected situations (directory not provided, not a git repo) vs. unexpected failures (git command error):

```python
def git_head(dirpath: Optional[Path]) -> Optional[Dict[str, str]]:
    if not dirpath:
        return None  # OK - directory not provided
    if not (dirpath / ".git").exists():
        return None  # OK - not a git repo
    commit = capture(["git", "rev-parse", "HEAD"], cwd=dirpath) or None
    desc = capture(["git", "describe", "--always", "--dirty"], cwd=dirpath) or None
    remote = capture(["git", "remote", "get-url", "origin"], cwd=dirpath) or None
    if not (commit or remote or desc):
        return None  # ‚ö†Ô∏è Could be git error OR empty repo
    return {"dir": str(dirpath), "commit": commit, "describe": desc, "remote": remote}
```

Combined with the silent `capture()` exceptions, git command failures are indistinguishable from "no git repo" scenarios.

**Recommendation:**
Make git failures explicit:

```python
def git_head(dirpath: Optional[Path]) -> Optional[Dict[str, str]]:
    """
    Get git metadata for a directory.

    Returns None if directory is not provided or is not a git repository.
    Raises exception if directory is a git repo but git commands fail.
    """
    if not dirpath:
        return None
    if not (dirpath / ".git").exists():
        return None

    try:
        commit = capture(["git", "rev-parse", "HEAD"], cwd=dirpath)
        desc = capture(["git", "describe", "--always", "--dirty"], cwd=dirpath)
        remote = capture(["git", "remote", "get-url", "origin"], cwd=dirpath)
    except subprocess.CalledProcessError as e:
        raise RuntimeError(
            f"Failed to get git info from {dirpath}: {e}"
        ) from e

    return {
        "dir": str(dirpath),
        "commit": commit,
        "describe": desc,
        "remote": remote,
    }
```

---

#### 5. Manifest Generation Failure Doesn't Fail the Build (build_prod_wheels.py:535)

**File:** `build_prod_wheels.py`
**Location:** Line 535 (in diff)

**Issue:**
The call to `exec(cmd, cwd=script_dir)` doesn't have any error handling context. If the manifest script fails, it will propagate up and potentially fail the build, which is correct. However, there's no log message to clarify what happened.

**Current code:**
```python
exec(cmd, cwd=script_dir)
```

**Recommendation:**
Add context around the call:

```python
print("--- Generating PyTorch build manifest")
try:
    exec(cmd, cwd=script_dir)
    print("--- Manifest generation completed successfully")
except Exception as e:
    print(f"ERROR: Manifest generation failed: {e}")
    raise  # Re-raise to fail the build
```

This makes it clearer in build logs when/why manifest generation failed.

---

#### 6. Missing Validation for Required Manifest Fields (generate_pytorch_manifest.py:210-229)

**File:** `generate_pytorch_manifest.py`
**Location:** Lines 210-229

**Issue:**
The manifest is constructed with optional fields that may be `None`, but there's no validation that critical fields are present:

```python
manifest: Dict[str, Any] = {
    "project": "TheRock",
    "component": "pytorch",
    "build_type": "external",
    "artifact_group": args.artifact_group,
    "platform": platform_id,
    "run_id": run_id,  # May be None
    "job_id": job_id,  # May be None
    "rocm_sdk_version": args.rocm_sdk_version,  # May be None
    "pytorch_rocm_arch": args.pytorch_rocm_arch,  # May be None
    "version_suffix": args.version_suffix,  # May be None
    # ...
}
```

Downstream consumers of the manifest may rely on certain fields being present.

**Recommendation:**
Either:
1. Make critical fields required (raise error if None)
2. Document which fields are optional vs. required
3. Add a JSON schema for the manifest format

Example:
```python
# Validate required fields
if not args.rocm_sdk_version:
    raise ValueError("--rocm-sdk-version is required for manifest generation")
if not args.pytorch_rocm_arch:
    raise ValueError("--pytorch-rocm-arch is required for manifest generation")

manifest: Dict[str, Any] = {
    # ... guaranteed non-None fields
}
```

Or at minimum, document the schema in a docstring or separate schema file.

---

#### 7. Wheel Metadata Lacks Framework-Specific Information (generate_pytorch_manifest.py:186-196)

**File:** `generate_pytorch_manifest.py`
**Location:** Lines 186-196

**Issue:**
The wheel metadata only includes generic labels but doesn't capture PyTorch-specific information like CUDA/ROCm architecture:

```python
"labels": {
    "framework": "pytorch",
    "build_variant": os.getenv("BUILD_VARIANT", "release"),
    **meta,  # Just wheel filename parsing
},
```

The `pytorch_rocm_arch` is captured at the top level of the manifest but not per-artifact. This makes it harder to:
- Identify which wheels support which GPU architectures
- Filter/search wheels by architecture in downstream tooling

**Recommendation:**
Add ROCm arch to artifact labels:

```python
"labels": {
    "framework": "pytorch",
    "build_variant": os.getenv("BUILD_VARIANT", "release"),
    "rocm_arch": args.pytorch_rocm_arch,  # Add this
    **meta,
},
```

---

### üí° SUGGESTIONS

#### 8. Consider Using dataclass for Structured Data

**File:** `generate_pytorch_manifest.py`
**Location:** Throughout

**Suggestion:**
The manifest uses nested dictionaries with `Dict[str, Any]` types. Per CLAUDE.md Python style guidelines, consider using `@dataclass` for structured data:

```python
from dataclasses import dataclass, asdict
from typing import Optional, List

@dataclass
class WheelMetadata:
    distribution: str
    version: str
    python_tag: str
    abi_tag: str
    platform_tag: str
    build_tag: Optional[str] = None

@dataclass
class ArtifactInfo:
    relative_path: str
    size_bytes: int
    labels: dict

@dataclass
class GitSourceInfo:
    dir: str
    commit: str
    describe: str
    remote: str

@dataclass
class Manifest:
    project: str
    component: str
    build_type: str
    artifact_group: str
    platform: str
    artifacts: List[ArtifactInfo]
    # ... other fields

# Usage:
manifest = Manifest(
    project="TheRock",
    component="pytorch",
    # ...
)
manifest_dict = asdict(manifest)
```

This provides:
- Type safety and autocompletion
- Clear documentation of manifest structure
- Validation at construction time

---

#### 9. Add --dry-run Mode for Testing

**Suggestion:**
Add a `--dry-run` flag to `generate_pytorch_manifest.py` that prints what would be generated without writing files:

```python
ap.add_argument(
    "--dry-run",
    action="store_true",
    help="Print manifest to stdout instead of writing to file"
)

# Later:
if args.dry_run:
    print(json.dumps(manifest, indent=2, sort_keys=True))
else:
    out_path.write_text(...)
```

This helps with testing and debugging the manifest generation.

---

#### 10. Add Manifest Schema Validation

**Suggestion:**
Consider adding JSON schema validation using a library like `jsonschema`:

```python
import jsonschema

MANIFEST_SCHEMA = {
    "type": "object",
    "required": ["project", "component", "build_type", "artifacts"],
    "properties": {
        "project": {"type": "string"},
        "component": {"type": "string"},
        "artifacts": {
            "type": "array",
            "items": {
                "type": "object",
                "required": ["relative_path", "size_bytes", "labels"],
                # ...
            }
        }
        # ...
    }
}

# Before writing:
jsonschema.validate(manifest, MANIFEST_SCHEMA)
```

This ensures manifests are always well-formed and catches errors early.

---

#### 11. Add Checksums for Wheels

**Suggestion:**
Include SHA256 checksums for each wheel in the manifest:

```python
import hashlib

def compute_sha256(filepath: Path) -> str:
    sha256 = hashlib.sha256()
    with open(filepath, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            sha256.update(chunk)
    return sha256.hexdigest()

# In the artifact loop:
artifacts.append({
    "relative_path": str(rel).replace("\\", "/"),
    "size_bytes": p.stat().st_size,
    "sha256": compute_sha256(p),  # Add this
    "labels": {
        # ...
    },
})
```

This enables:
- Integrity verification of downloaded wheels
- Detection of corrupted uploads/downloads
- Compliance with package distribution best practices

---

#### 12. Improve Error Messages for Wheel Parsing

**Suggestion:**
When wheel parsing fails, include the filename in error messages for easier debugging:

```python
for p in sorted(output_dir.rglob("*.whl")):
    rel = p.relative_to(output_dir)
    try:
        meta = parse_wheel_name(p.name)
    except ValueError as e:
        raise ValueError(f"Failed to parse wheel '{rel}': {e}") from e
    # ...
```

---

#### 13. Add Unit Tests

**Suggestion:**
Add tests for `generate_pytorch_manifest.py`, especially:
- `parse_wheel_name()` with valid and invalid inputs
- `git_head()` with various directory states
- Manifest generation with missing optional fields
- Platform ID generation on different OSes

Example test structure:
```python
# test_generate_pytorch_manifest.py

def test_parse_wheel_name_valid():
    result = parse_wheel_name("torch-2.9.1-cp313-cp313-linux_x86_64.whl")
    assert result["distribution"] == "torch"
    assert result["version"] == "2.9.1"
    # ...

def test_parse_wheel_name_invalid():
    with pytest.raises(ValueError, match="Not a wheel file"):
        parse_wheel_name("not-a-wheel.tar.gz")
```

---

#### 14. Document Manifest Format

**Suggestion:**
Add documentation explaining:
- What the manifest is for
- Schema/format specification
- How to consume it in downstream tools
- Example queries/use cases

Could be:
- Docstring at top of `generate_pytorch_manifest.py`
- Separate `docs/pytorch-manifest-format.md` file
- Comment in the workflow YAML files

---

#### 15. Consider Making S3 Upload Conditional

**File:** `.github/workflows/build_portable_linux_pytorch_wheels.yml`
**Location:** Lines 225-229 (in diff)

**Suggestion:**
The manifest upload step runs unconditionally (when `github.repository_owner == 'ROCm'`), but it might fail if no manifests were generated:

```yaml
- name: Upload PyTorch manifest to S3 artifacts
  if: ${{ github.repository_owner == 'ROCm' }}
  run: |
    aws s3 cp ${{ env.PACKAGE_DIST_DIR }}/manifests/ \
      s3://${{ env.S3_BUCKET_ARTIFACTS }}/external-builds/pytorch/${{ github.run_id }}/${{ inputs.amdgpu_family }}/ \
      --recursive --exclude "*" --include "*.json"
```

Consider checking if the manifests directory exists first:

```yaml
- name: Upload PyTorch manifest to S3 artifacts
  if: ${{ github.repository_owner == 'ROCm' }}
  run: |
    if [ -d "${{ env.PACKAGE_DIST_DIR }}/manifests" ]; then
      aws s3 cp ${{ env.PACKAGE_DIST_DIR }}/manifests/ \
        s3://${{ env.S3_BUCKET_ARTIFACTS }}/external-builds/pytorch/${{ github.run_id }}/${{ inputs.amdgpu_family }}/ \
        --recursive --exclude "*" --include "*.json"
    else
      echo "::warning::No manifests directory found, skipping upload"
    fi
```

---

### üìã FUTURE WORK

#### 16. Add Manifest Validation Step

Consider adding a CI step that validates uploaded manifests:
- Download manifest from S3
- Verify all referenced wheels exist
- Check SHA256 sums match
- Validate JSON schema

This catches issues early before manifests are consumed downstream.

---

#### 17. Support Incremental Builds

The current implementation generates a new manifest each time. For incremental builds where only some wheels are rebuilt, consider:
- Merging with existing manifests
- Marking which artifacts were rebuilt vs. reused
- Tracking build timestamps per artifact

---

## Detailed Analysis

### Architecture

**Approach:** The PR adds manifest generation as a post-build step, keeping it separate from the core build logic. This is a clean separation of concerns.

**Design Choices:**
- Manifest is generated after all builds complete (good - ensures all artifacts are available)
- Uses a separate Python script rather than inline code (good - testable and reusable)
- Upload happens in a separate workflow step (good - can be modified independently)

**Concerns:**
- Silent failure modes make debugging hard
- No validation of critical fields
- Manifest schema is implicit, not explicit

---

### Code Quality & Style

**Positive:**
- Clear function names and structure
- Good use of type hints in function signatures
- Decent comments explaining the manifest format

**Issues:**
- Violates CLAUDE.md fail-fast principle (bare `except Exception`)
- Uses `Dict[str, Any]` instead of `@dataclass` for structured data
- Missing docstrings on several functions
- Inconsistent error handling (some silent, some would raise)

**Per CLAUDE.md Python Style Guide:**
- ‚ùå Violates "fail-fast" - multiple silent exception handlers
- ‚ùå Violates "no tuples for structured data" - should use `@dataclass` instead of dicts
- ‚úì Has specific type hints (not using `Any` in signatures)
- ‚úì No magic numbers

---

### Testing

**Current State:**
- CI passes (pre-commit, setup only - no actual build run visible)
- No unit tests for the new script
- No integration tests

**Gaps:**
- No tests for `parse_wheel_name()` with edge cases
- No tests for manifest generation with missing fields
- No validation that uploaded manifests are well-formed
- No end-to-end test of manifest generation + upload

**Recommendation:**
Add unit tests before merge, especially for:
- Wheel name parsing (valid, invalid, edge cases)
- Git metadata extraction
- Manifest field validation

---

### Security

**No major security concerns**, but note:
- Manifest contains git commit SHAs and repo URLs (this is intentional for traceability)
- No sensitive credentials in manifest
- S3 bucket names are public (`therock-dev-artifacts`, `therock-prod-artifacts`)

---

### Performance

**No performance concerns.**
- Manifest generation is I/O bound (file reads, git commands)
- Happens after multi-hour wheel builds, so negligible overhead
- JSON serialization is fast

---

### Documentation

**Current:**
- Good PR description with example manifest
- Code comments explain intent
- Helpful argument descriptions in argparse

**Missing:**
- Docstrings on key functions (`parse_wheel_name`, `git_head`, `main`)
- Manifest schema documentation
- Guide for downstream consumers

---

## CI Status

All checks passing:
- ‚úÖ pre-commit (20s)
- ‚úÖ setup (6s)
- ‚úÖ CI Summary (3s)
- ‚è≠Ô∏è Build jobs skipped (expected - no test builds on this PR)

---

## Verdict

**‚ö†Ô∏è CHANGES RECOMMENDED (Not Blocking, but Important)**

This PR adds valuable functionality for build traceability and artifact management. The overall design is sound and the implementation is mostly clean. However, there are **three critical issues** that violate TheRock's Python coding standards:

1. **Silent exception handling** - Violates fail-fast principle, makes debugging difficult
2. **Silent wheel parsing failures** - Can produce invalid manifests
3. **No validation that wheels exist** - Can upload empty manifests

These should be fixed before merge to ensure:
- Build failures are visible and actionable
- Manifests are always valid and complete
- Debugging is straightforward when issues occur

**Recommended Next Steps:**

**High Priority:**

1. Fix silent exception handling in `capture()` and `git_head()`
2. Make `parse_wheel_name()` raise on invalid input
3. Validate that wheels exist before generating manifest
4. Add unit tests for the new script

**Medium Priority:**

5. Add manifest schema validation
6. Document the manifest format
7. Add checksums to wheel metadata

**Optional Improvements:**

8. Use `@dataclass` for structured data
9. Add `--dry-run` mode
10. Improve error messages

Once the high-priority items are addressed, this will be a solid addition to the build infrastructure. The functionality is clearly useful and the design is well thought out.
